# -*- coding: utf-8 -*-
"""Lab5_UrsuAndrei_312

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l2A_Z0YFG5j3WAs70sNdYhB_bN-5OPXj

# Proiect cautare (3p) (deadline 3 sapt de azi)

Rezolvati una dintre urmatoarele probleme folosind un algoritm de cautare neinformata si un algoritm de cautare informata (la alegere):

- Problema 8-puzzle
- Problema canibalilor si misionarilor
- Problema depasarii Arad-Bucuresti
- ...



Pasi rezolvare:


1.   Definiti graful de stari.
  
  a. Ce informatii trebuie retinute in fiecare nod?
  
  b. Cum se definesc arcele intre noduri / tranzitiile? Care sunt actiunile posibile?
  
  c. Care este starea initiala si care este starea finala?
  
  d. Exista costuri asociate arcelor? (altfel, costul fiecarui arc va fi 1)


...mai multe detalii in documentul PDF.

## Exercitii ajutatoare (rezolvate)

Exercitiile de mai jos contin exemple de rezolvare a problemelor de cautare mai complexe, ca cele pe care le veti rezolva pentru proiect, si anume implementari ale functiilor necesare, specifice problemei. Rezolvarile sunt orientative - sunt acceptabile mici modificari de implementare, cu pastrarea instructiunilor din PDF.

![graf_neor_1.png](data:image/png;base64,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AAAAAAAAAAAAAAD8//bggAQAAABA0P/X7QhUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgLcAR8k7mJHa3vAAAAAASUVORK5CYII=)

Scrieti o functie `succesor()` care, fiind dat un nod din graf reprezentat ca o matrice de adiacenta, sa returneze toate nodurile accesibile direct din el (vecinii). Luati ca exemplu graful de mai sus si apelati functia pe matricea lui.
"""

def succesor(mo, n):
  succesori = []
  for j in range(len(mo)):
    if mo[n-1][j] > 0:
      succesori.append(j+1)
  return succesori

m=[
    [0,1,1,1],
    [1,0,0,1],
    [1,0,0,0],
    [1,1,0,0],
  ]

print(succesor(m, 2))

"""Pentru problema intoarcerii clatitelor (vezi curs), definiti un mod de a reprezenta starile din graf, reprezentati starea initiala din imaginea de mai jos si retineti-o intr-o variabila, si scrieti functii potrivite pentru: `succesor()` si `test_scop()`.
Afisati starile in care se poate ajunge din 2 pasi pornind din starea initiala, si verificati daca sunt stari scop.

Actiunile valide sunt intoarcerea clatitelor din varful turnului cu o spatula. Se pot intoarce oricate clatite, de la 2 pana la maximul de clatite din turn.
Presupunem ca avem 4 clatite in total, cu diametrele: 1, 2, 3 si 4.
Scopul este sa ajungem in final cu turnul de clatite ordonat de la mic la mare (cea mai mare clatita la baza si cea mai mica in varf).

Folositi-va de o functie  `afisare_stare(s)` care sa afiseze starea curenta intr-un mod intuitiv la alegere.

Stare initiala: ![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFQAAAAyCAYAAADCxvyGAAAABHNCSVQICAgIfAhkiAAAABl0RVh0U29mdHdhcmUAZ25vbWUtc2NyZWVuc2hvdO8Dvz4AAAArdEVYdENyZWF0aW9uIFRpbWUATWEgMjEgbWFyIDIwMjMgMDQ6NDI6MjggKzAyMDBnfixyAAACmklEQVR4nO2ZzWoUQRSFz5UkmAkiLhKSiCtB3KuQVTaCgitfwIUbJbj3DfQlzDu41Bdw6UIQ3GQjggZcKSTBmTg3i+mful3dU5me0xlmcj/CpOb+dFcfpqpvVYmqKhwaV2bdgUXDBSXjgpJxQcm4oGRcUDIuKJkl7uUUqkMIBIAAAmQflwaqoH9+fMTBhycNXgFEasTuwg5ApNbeW7+P24/eMx/bQP+FjvWplhEaeS+E3vqDTq/PnUPnYRXb8QxEfinNgaAdKyrMzZHB8SEGx79QCKsKQDEa6JqZ83bKXubndmRXs3aU9yjsaLzHcm8Taxs7rEeOoArqeB1K5xyC+g94EpJl0/6rqxie9rNaDoCp8zCq78TaZxIHyVzpuNGfjYvya+J2n73DzbsPx+qVrkOLOT5/VShq/l0KCnHH4EN+Es5RcflLaSLSiibLpt/fP8PWlXktCGO308GUcdDM1W1cZM/ytCFu684uVq9tNEkFwOtQOj7kybTabdLTPgZ/D1Hd85R8y8xsqY3apnyp84stV7r1d7eebyXoyc+v+PbmHrsvF4wVe/vpW2w+fj31Vdvthy7EtBtsrBAfp+UcugiCWoQ0DfhLqYAjaKuyafjvCMP+EQBA8z1Is6eZt6fza1AHpv1xbK3f1JZle+XGLSxf35pUigivQ8n4kCfDOfU0p5nB8s98B+IlX+Yxy70gOxg88fCPl5hmsIXL3Mb4ss3qk+ztrOi4B013xAlZ+j/oz7oPC4XPoWRcUDJy8OWTAvHZS/V8pVxIVM9awpygOA7PgopQmyPljSr5lZyp+xXkSHiQUZ9T7Vfjs4T3yOO8DuXiQ56MC0rGBSXjgpJxQcm4oGRcUDIuKBkXlIwLSmauBH3+4uWsu5DkDIVYa+WM+N+uAAAAAElFTkSuQmCC)
"""

# Vom reprezenta starile ca liste ordonate de numere intregi (mai precis, vor functiona ca stive), unde
# fiecare element din lista reprezinta diametrul unei clatite din turn,
# in ordine de jos in sus (de la baza spre varf)

stare_initiala = [4, 2, 3, 1]

# Fiind data o stare s, returneaza celelalte stari in care pot ajunge prin tranzitii/actiuni din s.
# Fiind mai multe stari posibile, le putem returna grupate intr-o lista de stari.
def succesor(s):
  stari_succesor = []
  for cutoff in range(2, len(s)+1): # in cutoff vom retine cate clatite intoarcem cu spatula
    varful_stivei = s[len(s)-cutoff : len(s)] # luam o portiune din stiva s, si anume incepand de la clatita de la pozitia din varf - nr de clatite intoarse, pana la varf
    varful_stivei_intors = varful_stivei[::-1] # astfel se poate face inversarea elementelor unei liste in python
    baza_stivei = s[:len(s)-cutoff]
    stare_noua = baza_stivei + varful_stivei_intors
    stari_succesor.append(stare_noua)
  return stari_succesor

def stare_scop(s):
  # O stare este scop daca toate clatitele sunt ordonate:
  # orice clatita din stiva are diametrul mai mic decat orice clatita de sub ea.
  # Altfel spus, orice clatita trebuie sa fie mai mica decat cea de sub ea.
  for i in range(len(s)-1, 1, -1): # o luam invers de la sfarsitul listei la inceput, excluzand pozitia 0 (nu exista clatite sub ea)
    if s[i] > s[i-1]:
      return False # daca am gasit vreo pereche de stari in dezordine putem deja incheia functia cu False.
  # Daca am ajuns aici in functie inseamna ca nu am gasit nicio pereche de stari in dezordine si putem confirma ca este scop.
  return True

def afisare_stare(s):
  for diam in s[::-1]: # O iau de sus in jos in stiva, deci trebuie sa inversez lista
    liniute = ['-' for l in range(diam)]
    print("".join(liniute))

# Putem defini o functie succesor care ne si da detalii despre mutarea facuta pentru a ajunge la fiecare succesor.
def succesor_cu_mesaj(s_cu_mesaj):
  s = s_cu_mesaj["stare"]
  stari_succesor = []
  for cutoff in range(2, len(s)+1): # in cutoff vom retine cate clatite intoarcem cu spatula
    varful_stivei = s[len(s)-cutoff : len(s)] # luam o portiune din stiva s, si anume incepand de la clatita de la pozitia din varf - nr de clatite intoarse, pana la varf
    varful_stivei_intors = varful_stivei[::-1] # astfel se poate face inversarea elementelor unei liste in python
    baza_stivei = s[:len(s)-cutoff]
    stare_noua = baza_stivei + varful_stivei_intors
    # Creez un dictionar care retine si stare si mesajul corespunzator
    stari_succesor.append({"stare": stare_noua, "mesaj": f'Am intors {cutoff} clatite'})  # String formatat (https://docs.python.org/3/tutorial/inputoutput.html)
  return stari_succesor

print(succesor(stare_initiala))

print(succesor_cu_mesaj({"stare": stare_initiala, "mesaj": ""}))

afisare_stare(stare_initiala) # afisam starea ca o "stiva" desenata cu liniute

# Parcurgem doi pasi din starea initiala:
# Obs: in rezolvarea problemelor nu vom trece prin stari in acest mod "manual",
# ci vom folosi algoritmii de parcurgere invatati
s = {"stare": stare_initiala, "mesaj": ""}
succesori1 = succesor_cu_mesaj(s)
for s1 in succesori1: # primul pas
  print(s1["mesaj"]) # afisez mutarea
  print("starea", s1["stare"], "este stare scop?", stare_scop(s1["stare"]))
  print("Starea curenta afisata grafic: ")
  afisare_stare(s1["stare"])
  succesori2 = succesor_cu_mesaj(s1)
  for s2 in succesori2: # al doilea pas
    print(s2["mesaj"])
    print("starea", s2["stare"], "este stare scop?", stare_scop(s2["stare"]))
    print("Starea curenta afisata grafic: ")
    afisare_stare(s2["stare"])

# Inversarea unei liste in python
l = [1, 2, 3]
print(l[::-1])

# Slicing de liste in python
l = [1, 2, 3, 6, 2, 7, 5]
print(l[:5]) # primele 5 elemente
print(l[5:]) # elementele de la al 5lea pana la sfarsit (exclusiv)
print(l[2:5]) # elementele de la al 2lea la al 5lea (exclusiv)

"""Implementati o versiune modificata a algoritmului BFS pentru parcurgerea grafului desenat mai sus astfel incat sa foloseasca functia succesor."""

def breadth_first(nod_start):

    c=[nod_start]
    explorate = [] # Nota: aici nu am mai folosit set() pentru ca nu putem pune elemente de tip lista intr-un set.
                  # Atunci ori folosim o lista simpla in loc de set(), ori reprezentam elementele ca tupluri in loc de liste (tuplurile pot fi in set-uri)

    while len(c)>0:
        #print("Coada actuala: " + str(c))
        nod_curent=c.pop(0)
        print("Starea vizitata:")
        afisare_stare(nod_curent)

        if stare_scop(nod_curent):
            print("Am gasit o solutie.")
            break


        lSuccesori=succesor(nod_curent)
        for suc in lSuccesori:
          if suc not in c and suc not in explorate:  # Nota: apartenenta folosind "in" va functiona doar pentru anumite tipuri de date.
                                                    # Daca problema voastra cere o reprezentare mai complicata a starii (decat o lista)
                                                    # puteti scrie in schimb o functie `gasit` care sa verifice apartenenta (vezi mai jos)
            c.append(suc)

breadth_first(stare_initiala)

def gasit_liste(l1, l_mare):
  toate_egale = True
  for lista in l_mare:
    toate_egale = True
    for i in range(len(l1)):
      if l1[i] != lista[i]:
        toate_egale = False
      if i+1 < len(lista)-1:  # Nu am ajuns la sfarsitul listei din l_mare, e mai lunga decat l1
        toate_egale = False
    if toate_egale:
      return True
  return False

print(gasit_liste([2,3], [[5,6,7], [2,3], [6,8]]))

print([2,3] in [[5,6,7], [2,3], [6,8]])

"""Exercitiu nerezolvat: scrieti variante asemanatoare ale algoritmilor DFS, UCS, Greedy si A*, care folosesc functii `succesor`, `test_scop` si `afisare_stare` si, pe baza unei stari initiale, parcurg "arborele de cautare" (care nu va mai fi codificat explicit, cum am vazut la laboratorul anterior).


*Nota*: acest exercitiu nu se va nota ca parte din tema, insa rezolvarea lui este parte din rezolvarea mini-proiectului.
*Nota*: in functie de problema aleasa, puteti gandi moduri specifice pentru afisarea starii, generarea succesorilor, afisarea mutarilor etc. Afisarea mutarilor si a drumului este optionala, insa cu cat solutia este mai intuitiv descrisa pentru problema aleasa, cu atat mai bine.

Nota: pentru algoritmii de cautare informata, veti avea nevoie si de o functie `euristica(s)` care sa va dea valoarea euristicii pentru fiecare stare. Puteti alege ce euristica vreti, aveti grija sa fie admisibila (putem discuta la prezentari cum ati gandit alegerea).
"""

